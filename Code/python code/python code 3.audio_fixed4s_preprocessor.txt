# 重复、切割和补零，输出固定为 python code 3.audio_fixed4s_preprocessor

import os
import math
import random
import numpy as np
import soundfile as sf
import pandas as pd  # 用于导出 Excel


def pad_audio(audio, target_length):
    """对音频在两端均匀补零，使总长度达到 target_length（单位：样本数）。"""
    current_length = len(audio)
    if current_length >= target_length:
        return audio
    pad_total = target_length - current_length
    pad_left = pad_total // 2
    pad_right = pad_total - pad_left
    return np.pad(audio, (pad_left, pad_right), mode='constant', constant_values=0)


def crop_audio(audio, target_length):
    """随机截取长度为 target_length 的音频片段（单位：样本数）。"""
    current_length = len(audio)
    if current_length <= target_length:
        return audio
    start = random.randint(0, current_length - target_length)
    return audio[start:start + target_length]


def process_audio(audio, sr):
    """
    处理音频，确保输出为 4 秒（4*sr 个采样点）的片段，处理规则如下：

    1. 音频长度 < 1.5 秒：不处理，不输出。
    2. 音频长度在 1.5 秒 - 2.0 秒之间：随机间隔重复一次（间隔在 0.5-0.75 秒之间），
       然后如果长度不足 4 秒则对音频两端均匀补零；若超过 4 秒则随机截取 4 秒片段。
    3. 音频长度在 2.0 秒 - 3.0 秒之间：无间隔重复一次，然后随机截取其中的 4 秒片段。
    4. 音频长度在 3.0 秒 - 4.0 秒之间：直接对音频两端均匀补零至 4 秒。
    5. 音频长度在 4 秒 - 8 秒之间：随机截取 4 秒音频片段。
    6. 音频长度 >= 8 秒：将音频分割成若干个互不重叠的 4 秒片段，
       截取个数为音频总长度除以 4 秒（向下取整）。
    """
    target_length = 4 * sr
    audio_duration = len(audio) / sr
    processed_segments = []

    if audio_duration < 1.5:
        # 音频长度不足1.5秒，不处理，不输出
        return processed_segments

    elif audio_duration < 2.0:
        # 随机间隔重复一次（间隔在0.5-0.75秒之间）
        gap_duration = random.uniform(0.5, 0.75)
        gap_samples = int(gap_duration * sr)
        repeated_audio = np.concatenate([audio, np.zeros(gap_samples), audio])
        # 如果不足4秒则补零，否则随机截取4秒片段
        if len(repeated_audio) < target_length:
            seg = pad_audio(repeated_audio, target_length)
        else:
            seg = crop_audio(repeated_audio, target_length)
        processed_segments.append(seg)

    elif audio_duration < 3.0:
        # 无间隔重复一次，然后随机截取4秒片段
        repeated_audio = np.concatenate([audio, audio])
        seg = crop_audio(repeated_audio, target_length)
        processed_segments.append(seg)

    elif audio_duration < 4.0:
        # 直接补零至4秒
        seg = pad_audio(audio, target_length)
        processed_segments.append(seg)

    elif audio_duration < 8.0:
        # 随机截取4秒片段
        seg = crop_audio(audio, target_length)
        processed_segments.append(seg)

    else:
        # 音频长度>=8秒，从中截取多个不重叠的4秒片段
        num_segments = len(audio) // target_length  # 向下取整
        for i in range(int(num_segments)):
            seg = audio[int(i * target_length): int((i + 1) * target_length)]
            processed_segments.append(seg)

    return processed_segments


def process_folder(input_folder, output_folder, ext="wav"):
    """
    遍历输入文件夹及其所有子文件夹，对音频进行处理，并保持目录结构存储至输出文件夹。

    同时统计音频长度不足1.5秒的文件，并在输出文件夹中导出 Excel 文件（skipped_files.xlsx）。

    参数：
        input_folder: str，输入文件夹路径
        output_folder: str，输出文件夹路径
        ext: str，音频文件后缀（默认wav）
    """
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    # 用于存储跳过处理的文件信息
    skipped_files = []

    # 遍历所有子目录和文件
    for root, _, files in os.walk(input_folder):
        # 计算相对路径，保持原始目录结构
        relative_path = os.path.relpath(root, input_folder)
        output_subfolder = os.path.join(output_folder, relative_path)
        if not os.path.exists(output_subfolder):
            os.makedirs(output_subfolder)

        # 处理当前文件夹下的音频文件
        audio_files = [f for f in files if f.endswith(f".{ext}")]
        print(f"在 {root} 目录下找到 {len(audio_files)} 个 {ext} 文件。")

        for file in audio_files:
            file_path = os.path.join(root, file)
            try:
                # 读取音频，并自动获取采样率
                audio, file_sr = sf.read(file_path)
                if len(audio.shape) > 1:
                    audio = np.mean(audio, axis=1)  # 转换为单声道

                audio_duration = len(audio) / file_sr
                if audio_duration < 1.5:
                    print(f"{file_path} 音频长度不足1.5秒，跳过处理。")
                    skipped_files.append({
                        "file_path": file_path,
                        "file_name": file,
                        "duration_sec": round(audio_duration, 2),
                        "reason": "音频长度不足1.5秒"
                    })
                    continue

                segments = process_audio(audio, file_sr)
                if not segments:
                    # 理论上不会走到这里，因为已提前判断
                    continue

                # 保存处理后的音频片段，采样率与原文件保持一致
                base_name = os.path.splitext(file)[0]
                for i, seg in enumerate(segments):
                    out_name = f"{base_name}_seg{i + 1}.{ext}"
                    out_path = os.path.join(output_subfolder, out_name)
                    sf.write(out_path, seg, file_sr)
                    print(f"保存: {out_path}")
            except Exception as e:
                print(f"处理 {file_path} 失败: {e}")

    # 如果有跳过的文件，则导出 Excel 记录
    if skipped_files:
        df = pd.DataFrame(skipped_files)
        excel_path = os.path.join(output_folder, "skipped_files.xlsx")
        df.to_excel(excel_path, index=False)
        print(f"保存跳过文件统计: {excel_path}")


if __name__ == '__main__':
    # 指定多个输入文件夹与对应的输出文件夹
    folder_pairs = [
        (r"E:\voice_data\LX_独立test_2\qiege", r"E:\voice_data\LX_独立test_2\4_second"),
        # 可继续添加更多文件夹对，例如：
        # ("E:/voice_data/Folder1", "E:/voice_data/Output1"),
        # ("E:/voice_data/Folder2", "E:/voice_data/Output2"),
    ]

    for input_folder, output_folder in folder_pairs:
        print(f"开始处理: {input_folder} -> {output_folder}")
        process_folder(input_folder, output_folder, ext="wav")





