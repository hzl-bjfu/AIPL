# 只生成numpy，非gpu （自动跳过转换过的文件） python code 4.wav_to_mel_numpy
import os
import numpy as np
import librosa

# ==== 配置参数 ====
SR = 48000  # 采样率
DURATION = 4.0  # 音频长度（秒）
N_FFT = 1024  # FFT 点数
HOP_LENGTH = 512  # 帧移
N_MELS = 128  # 梅尔滤波器组数

# ==== 输入和输出文件夹（可指定多个） ====
INPUT_FOLDERS = [
    rF谢老师组_绿心公园北京城市绿心森林公园4secondLXA005_4second,
    rF谢老师组_绿心公园北京城市绿心森林公园4secondLXB004_4second,
    rF谢老师组_绿心公园北京城市绿心森林公园4secondLXB005_4second,
    rF谢老师组_绿心公园北京城市绿心森林公园4secondLXB006_4second,
    rF谢老师组_绿心公园北京城市绿心森林公园4secondLXC004_4second,
    rF谢老师组_绿心公园北京城市绿心森林公园4secondLXC005_4second,
    rF谢老师组_绿心公园北京城市绿心森林公园4secondLXC006_4second
]

OUTPUT_NPY_FOLDERS = [
    r'F谢老师组_绿心公园北京城市绿心森林公园nympyLXA005_npy',
    r'F谢老师组_绿心公园北京城市绿心森林公园nympyLXB004_npy',
    r'F谢老师组_绿心公园北京城市绿心森林公园nympyLXB005_npy',
    r'F谢老师组_绿心公园北京城市绿心森林公园nympyLXB006_npy',
    r'F谢老师组_绿心公园北京城市绿心森林公园nympyLXC004_npy',
    r'F谢老师组_绿心公园北京城市绿心森林公园nympyLXC005_npy',
    r'F谢老师组_绿心公园北京城市绿心森林公园nympyLXC006_npy'
]


def process_audio(input_path, output_npy_path)
    读取音频文件，转换为梅尔频谱图并保存为 numpy 文件
    try
        # 读取音频，并合并左右声道为单声道
        signal, sr = librosa.load(input_path, sr=SR, mono=True, duration=DURATION)

        # 若音频长度小于4秒，则在末尾补零
        if len(signal)  int(SR  DURATION)
            signal = np.pad(signal, (0, int(SR  DURATION) - len(signal)), mode='constant')

        # 计算梅尔频谱图并转换为 dB 单位
        S = librosa.feature.melspectrogram(y=signal, sr=sr, n_fft=N_FFT, hop_length=HOP_LENGTH, n_mels=N_MELS)
        S_db = librosa.power_to_db(S, ref=np.max)

        # 保存梅尔频谱数据为 .npy 格式
        np.save(output_npy_path, S_db)

        print(fProcessed {input_path}n  - Numpy {output_npy_path})

    except Exception as e
        print(fError processing {input_path} {e})


def process_directory(input_folder, output_npy_folder)
    遍历输入文件夹，处理所有音频，同时保持目录结构到输出 numpy 文件夹
    for root, _, files in os.walk(input_folder)
        for filename in files
            if filename.endswith(.wav)
                input_path = os.path.join(root, filename)
                # 计算相对路径，保持目录结构
                relative_path = os.path.relpath(root, input_folder)
                output_npy_subfolder = os.path.join(output_npy_folder, relative_path)
                os.makedirs(output_npy_subfolder, exist_ok=True)

                # 生成输出 numpy 文件路径
                output_npy_path = os.path.join(output_npy_subfolder, filename.replace(.wav, .npy))

                # 如果目标 npy 文件已存在，则跳过处理
                if os.path.exists(output_npy_path)
                    print(fSkipping (already processed) {input_path})
                    continue

                process_audio(input_path, output_npy_path)


# ==== 主程序 ====
if __name__ == '__main__'
    # 检查输入和输出文件夹数量是否匹配
    if len(INPUT_FOLDERS) != len(OUTPUT_NPY_FOLDERS)
        raise ValueError(输入文件夹和输出文件夹数量不匹配！)

    # 遍历所有输入文件夹并处理
    for input_folder, output_npy_folder in zip(INPUT_FOLDERS, OUTPUT_NPY_FOLDERS)
        print(fn正在处理文件夹 {input_folder})
        print(f输出到 {output_npy_folder})
        process_directory(input_folder, output_npy_folder)

    print(n所有音频处理完成！)
