# python code 1.audio_segmentation_by_tags 切割音频
import os
import pandas as pd
from pydub import AudioSegment
import re


def clean_tag(tag):
    # 确保 tag 是字符串
    if not isinstance(tag, str):
        tag = str(tag)  # 如果不是字符串，则转换为字符串
    # 定义非法字符的正则表达式
    invalid_chars = r'[<>:"/\\|?*]'
    # 用空字符串替换非法字符
    return re.sub(invalid_chars, '_', tag)


def extract_wav_filename(txt_filename):
    """
    从 TXT 文件名中提取 WAV 文件名。
    例如：DT0H_20240601_040519.Table.1.selections.txt -> DT0H_20240601_040519.wav
    """
    # 提取前缀（假设前缀是文件名中第一个点之前的部分）
    prefix = txt_filename.split('.')[0]
    return f"{prefix}.wav"


def build_wav_dict(wav_dir):
    """
    遍历 wav_dir 及其所有子文件夹，构建一个字典，
    键为 wav 文件名，值为完整路径。
    """
    wav_dict = {}
    for root, dirs, files in os.walk(wav_dir):
        for file in files:
            if file.lower().endswith(".wav"):
                wav_dict[file] = os.path.join(root, file)
    return wav_dict


def slice_audio(txt_dir, wav_dir, output_dir):
    # 构建 wav 文件字典
    wav_files = build_wav_dict(wav_dir)

    # 创建一个空的 DataFrame 用于记录所有切割片段的信息
    all_segments_info = pd.DataFrame(
        columns=["Original WAV", "Segment WAV", "Begin Time (s)", "End Time (s)", "Length", "Tag"])

    # 遍历 txt_dir 及其所有子文件夹下的 TXT 文件
    for root, dirs, files in os.walk(txt_dir):
        for txt_file in files:
            if txt_file.lower().endswith(".txt"):
                txt_file_path = os.path.join(root, txt_file)
                # 获取对应的 wav 文件名
                wav_file_name = extract_wav_filename(txt_file)

                # 从 wav_files 字典中查找完整路径
                if wav_file_name in wav_files:
                    wav_file_path = wav_files[wav_file_name]
                else:
                    print(f"Warning: WAV file {wav_file_name} not found for TXT file {txt_file_path}.")
                    continue

                # 读取 TXT 文件时指定编码（例如 gbk）
                try:
                    df = pd.read_csv(txt_file_path, delimiter='\t', encoding='gbk')
                except UnicodeDecodeError:
                    # 如果 gbk 编码不合适，也可以尝试使用其他编码，比如 latin1
                    df = pd.read_csv(txt_file_path, delimiter='\t', encoding='latin1')

                # 检查必要的列是否存在
                required_columns = ['Begin Time (s)', 'End Time (s)', 'tag']
                if not all(column in df.columns for column in required_columns):
                    print(f"Error: TXT 文件 {txt_file_path} 缺少必要的列。")
                    continue

                # 加载音频文件
                audio = AudioSegment.from_wav(wav_file_path)

                # 按照 tag 分类并创建相应的文件夹
                for _, row in df.iterrows():
                    tag = row['tag']
                    # 如果标签为空，则跳过该记录
                    if not tag or str(tag).strip() == "":
                        print(f"Warning: 空标签，跳过文件 {txt_file_path} 中的记录。")
                        continue

                    begin_time = row['Begin Time (s)'] * 1000  # 转换为毫秒
                    end_time = row['End Time (s)'] * 1000  # 转换为毫秒

                    # 清理 tag 中的非法字符
                    clean_tag_name = clean_tag(tag)

                    # 切割音频片段
                    audio_segment = audio[begin_time:end_time]

                    # 创建输出路径
                    tag_folder = os.path.join(output_dir, clean_tag_name)
                    os.makedirs(tag_folder, exist_ok=True)

                    # 保存切割后的片段
                    segment_filename = f"{wav_file_name}_{int(begin_time)}_{int(end_time)}.wav"
                    output_path = os.path.join(tag_folder, segment_filename)
                    audio_segment.export(output_path, format="wav")
                    print(f"Saved {output_path}")

                    # 计算片段长度
                    length = row['End Time (s)'] - row['Begin Time (s)']

                    # 记录切割片段的信息
                    segment_info = pd.DataFrame({
                        "Original WAV": [wav_file_name],
                        "Segment WAV": [segment_filename],
                        "Begin Time (s)": [row['Begin Time (s)']],
                        "End Time (s)": [row['End Time (s)']],
                        "Length": [length],
                        "Tag": [tag]
                    })
                    all_segments_info = pd.concat([all_segments_info, segment_info], ignore_index=True)

    # 保存所有切割片段的信息到 CSV 文件
    csv_output_path = os.path.join(output_dir, "audio_segments_info.csv")
    all_segments_info.to_csv(csv_output_path, index=False)
    print(f"CSV 文件已生成: {csv_output_path}")


# 设置路径
txt_dir = r"E:\voice_data\LX_voice_data\LX_分类_txt\LXC004_0925_txt"  # TXT 文件根目录（包括子文件夹）
wav_dir = r"E:\voice_data\LX_voice_data"  # WAV 文件根目录（包括子文件夹）
output_dir = r"E:\voice_data\LX_独立test_2\qiege"  # 输出路径

# 执行切割
slice_audio(txt_dir, wav_dir, output_dir)
